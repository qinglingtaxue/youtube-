# 知识大法新手教程

> 让 AI 帮你干活，而不是给你添乱。

## 写在前面

你可能遇到过这些问题：
- 让 AI 写代码，它写了一堆，但改来改去总是不对
- 项目越做越乱，自己都忘了哪个文件是干什么的
- AI 产生幻觉，说的东西根本不存在
- 花了很多时间，但产出很少

这套方法能帮你解决这些问题。核心就五件事：

```
初始化 → 知识单元 → 唯一编码 → 对齐 → 分组
```

学完这个教程，你会明白：
- 怎么让 AI 不产生幻觉
- 怎么让 AI 帮你找到更好的方案
- 怎么快速定位问题
- 怎么在复杂项目中保持清晰

---

### 心态转变：成为 AI 的 CEO

在学习具体方法之前，先转变一个心态。

### AI 是聪明的实习生，你是老板

```
AI 再聪明，来到你的"公司"也是一个聪明的实习生。

实习生的特点：
- 学习能力强
- 执行速度快
- 但不了解公司业务
- 需要明确的指导

老板的特点：
- 最清楚公司业务
- 知道什么是好的、什么是坏的
- 做最终决策
- 承担结果
```

**你要做的不是"用 AI"，而是"管理 AI"。**

### 老板的上限决定 AI 的上限

```
垃圾老板 → 垃圾指令 → 垃圾产出 → 破产

优秀老板 → 清晰指令 → 高质量产出 → 成功
```

**在同样的 AI 能力下，人的认知不同，决定了 AI 产出的不同。**

这就是为什么：
- 同样的 AI，有人效率提升 10 倍，有人原地踏步
- 同样的代码库，有人 3 天完成，有人 3 周还在挣扎

AI 在不断迭代进步，但**你的认知水平决定了你能用出多少**。

### AI 的视角 vs 人的视角

```
人的视角：
- 需要切换项目、切换页面
- 一次只能看一个窗口
- 跨项目要"打开另一个文件夹"

AI 的视角：
- 整个电脑对它来说都一样
- 不需要"切换页面"（页面是给人看的）
- 跨项目？只是不同的路径而已
```

**启示**：不要用人的局限来限制 AI。

你可以让 AI：
- 同时参考项目 A 和项目 B 的代码
- 把项目 A 的好设计"搬"到项目 B
- 在整个电脑范围内找最佳实践

### 两类知识：行业标准 vs 个人品味

作为老板，你要告诉 AI 两类知识：

**第一类：行业标准**
```
"这是 RESTful API 的规范，照着做就行"
"这是 PEP 8 代码风格，遵守它"
"这是 Git commit 的规范格式"
```
→ AI 自己就能学会，你只需指明方向。

**第二类：个人品味**
```
"我喜欢这个网站的风格，学它"
"我觉得这个工作流很顺，参考它"
"这个 README 写得好，照着写"
```
→ AI 不知道你喜欢什么，**你得拿具体的参考示例给它看**。

这就是为什么"对齐"这么重要——**品味无法用语言完全描述，但可以用示例传递**。

### 孔子早就说过

> **见贤思齐焉，见不贤而内自省也。**

翻译成 AI 时代的语言：

- **见贤思齐**：看到好的（榜样库、优秀版本），向它学习
- **见不贤而内自省**：看到差的（失败的尝试），反思哪里出了问题

这不就是"对齐"吗？

---

## 第一章：项目初始化（最容易被忽视，却最重要）

### 为什么初始化这么重要？

一个真实案例：

> 同事们做了三周的项目，我接手后 **3 天就完成了**。
>
> 我们用的是**同样的 AI 模型、同样的代码库**。
>
> 差距在哪？**我花了 3-5 小时做项目初始化，他们一上来就干活。**

初始化不是浪费时间，而是**让后面所有工作效率提升 10 倍的投资**。

### 初始化三件套

```
1. Git 初始化（告诉版本控制忽略什么）
2. Claude 初始化（告诉 AI 忽略什么、关注什么）
3. 核心文档（告诉 AI 项目的规则和约束）
```

---

### 1. Git 初始化

#### 为什么需要 .gitignore？

```
❌ 不设置 .gitignore：
   - 隐私文件（密码、API Key）被上传
   - 大文件（视频、数据库）塞满仓库
   - node_modules 几万个文件污染仓库

✓ 设置 .gitignore：
   - 只保留核心代码
   - 敏感信息安全
   - 仓库干净清爽
```

#### 实战：创建 .gitignore

在项目根目录创建 `.gitignore` 文件：

```gitignore
# 敏感信息
.env
secrets.yaml
credentials.json
*_secret*
*_key*

# 大文件
*.mp4
*.mov
*.zip
data/raw/
*.db

# 依赖目录
node_modules/
.venv/
__pycache__/

# 系统文件
.DS_Store
Thumbs.db

# 日志
logs/
*.log
```

**原则**：不确定要不要忽略？先忽略，需要时再加回来。

---

### 2. Claude 初始化（关键！）

#### 为什么需要告诉 Claude 忽略什么？

真实踩坑案例：

> 一个同事问我 Python 问题，但新版项目根本没用 Python。
>
> 原因：他没配置 Claude 忽略，**Claude 扫描到了旧代码库，产生了幻觉**。

另一个案例：

> 项目里有一个 6G 的数据文件。
>
> Claude 试图扫描它，**直接死机了**。

#### 实战：创建 .claudeignore

在项目根目录创建 `.claudeignore` 文件（如果你用的是 Claude Code）：

```
# 大文件（Claude 扫描会死机）
data/raw/
*.db
*.sqlite
*.csv
*.json
!package.json
!tsconfig.json

# 旧代码（避免 Claude 产生幻觉）
legacy/
old/
backup/
deprecated/

# 依赖（没必要扫描）
node_modules/
.venv/
vendor/

# 生成的文件
dist/
build/
.next/

# 二进制文件
*.mp4
*.mp3
*.png
*.jpg
*.pdf
```

**原则**：
- 大于 1MB 的文件，考虑忽略
- 不是你写的代码（依赖、生成物），忽略
- 旧版本代码，忽略（避免幻觉）

#### 不同工具的忽略配置

| 工具 | 忽略文件 | 位置 |
|------|----------|------|
| Claude Code | `.claudeignore` | 项目根目录 |
| Cursor | `.cursorignore` | 项目根目录 |
| GitHub Copilot | 设置中配置 | IDE 设置 |
| 通用方法 | 在提示词中说明 | 每次对话开头 |

**通用方法示例**（如果工具不支持忽略文件）：

```
提示词开头加上：

在这个项目中，请忽略以下目录和文件：
- data/ 目录（大数据文件）
- legacy/ 目录（旧代码，不要参考）
- node_modules/（依赖）

只关注 src/ 目录下的代码。
```

---

### 3. 核心文档（CLAUDE.md）

#### 为什么需要核心文档？

AI 不知道你的项目有什么特殊规则。比如：
- 你的命名规范是什么？
- 哪些文件是核心文件？
- 有什么踩过的坑要避免？

**核心文档 = 项目的"使用说明书"，给 AI 看的。**

#### 实战：创建 CLAUDE.md

在项目根目录创建 `CLAUDE.md`（或 `.claude/CLAUDE.md`）：

```markdown
# 项目名称

## 项目概述
这是一个 YouTube 视频分析工具，用于...

## 技术栈
- 语言：Python 3.10+
- 框架：FastAPI
- 数据库：SQLite

## 目录结构
```
src/
├── research/    # 数据采集
├── analysis/    # 数据分析
├── report/      # 报告生成
└── shared/      # 共享模块
```

## 命名规范
- 文件名：snake_case（如 data_collector.py）
- 类名：PascalCase（如 DataCollector）
- 函数名：snake_case（如 collect_videos）

## 核心约束（踩坑经验）
1. 搜索 YouTube 必须用原生 sp 参数过滤时间，不能本地过滤
2. 数据库操作必须用事务
3. 所有 API 调用必须有重试机制

## 常用命令
```bash
# 启动服务
python -m src.main

# 运行测试
pytest tests/

# 采集数据
python -m src.research.collector --keyword="养生"
```
```

#### 核心文档的三个必备部分

| 部分 | 内容 | 作用 |
|------|------|------|
| 项目概述 | 这是什么、干什么用 | 让 AI 理解上下文 |
| 目录结构 | 什么文件在哪 | 让 AI 知道去哪找 |
| 核心约束 | 踩过的坑、必须遵守的规则 | 避免 AI 重复犯错 |

---

### 初始化检查清单

每次开始新项目，花 10-30 分钟过一遍：

```
□ Git 初始化
  □ 创建 .gitignore
  □ 敏感信息已忽略（.env、密钥）
  □ 大文件已忽略（数据、视频）
  □ 依赖目录已忽略

□ Claude 初始化
  □ 创建 .claudeignore（或等效配置）
  □ 大文件已忽略（>1MB）
  □ 旧代码已忽略（避免幻觉）
  □ 生成物已忽略（dist、build）

□ 核心文档
  □ 创建 CLAUDE.md
  □ 写了项目概述
  □ 写了目录结构
  □ 写了核心约束（踩坑经验）
```

---

### 提示词模板：让 AI 帮你初始化

如果你不确定该忽略什么，可以问 AI：

```
我要开始一个 [项目类型] 项目，使用 [技术栈]。

请帮我生成：
1. .gitignore 文件内容
2. .claudeignore 文件内容（告诉 AI 忽略什么）
3. CLAUDE.md 模板（项目说明文档）

项目特点：
- [特点1]
- [特点2]
```

**但记住**：AI 生成的只是起点，你需要根据实际情况调整。

---

## 第一章：知识单元

### 什么是知识单元？

**知识单元 = 可以独立存在、独立校验的最小信息块**

就像乐高积木，每一块都是独立的，可以单独检查它是不是完好的。

### 反面例子：没有知识单元

假设你在做一个 YouTube 视频分析项目，你可能会这样存数据：

```
视频数据.txt
---
标题：如何学习编程
播放量：10万
频道：小明说技术
---
标题：Python入门
播放量：5万
频道：编程小白
---
（还有500条...）
```

问题：
- 怎么知道第 237 条数据是对是错？
- 怎么单独更新某一条？
- AI 怎么精准定位到某条数据？

### 正面例子：有知识单元

```json
{
  "ku_id": "vid_abc123",
  "ku_type": "video",
  "title": "如何学习编程",
  "view_count": 100000,
  "channel_name": "小明说技术",
  "quality_score": 0.95,
  "status": "validated"
}
```

每条数据都是一个独立的知识单元：
- 有唯一 ID（`ku_id`）
- 有类型标记（`ku_type`）
- 有质量分数（`quality_score`）
- 有状态（`status`）

### 实战练习 1：把笔记变成知识单元

**任务**：你有一堆读书笔记，把它们变成知识单元。

**之前**：
```
《原则》笔记
- 痛苦+反思=进步
- 要极度透明
- 相信可信度加权
```

**之后**：
```json
{
  "ku_id": "note_20260201_001",
  "ku_type": "book_note",
  "book": "原则",
  "author": "瑞·达利欧",
  "insight": "痛苦+反思=进步",
  "my_comment": "这和刻意练习的理念很像",
  "created_at": "2026-02-01",
  "tags": ["成长", "反思"],
  "status": "permanent"
}
```

**为什么这样更好？**
- 每条笔记都可以单独查找、更新、引用
- AI 可以精准定位："帮我找所有关于'反思'的笔记"
- 你可以追踪每条笔记的状态（临时/永久）

### 知识单元的三个必备要素

| 要素 | 说明 | 例子 |
|------|------|------|
| 唯一 ID | 全局唯一，不能重复 | `note_20260201_001` |
| 类型 | 说明这是什么类型的单元 | `book_note`, `video`, `idea` |
| 状态 | 当前处于什么阶段 | `draft`, `validated`, `archived` |

---

## 第二章：唯一编码

### 为什么需要唯一编码？

#### 传统做法的灾难

```
你：帮我改一下那个处理用户数据的文件
AI：让我找一下...
AI：找到这些文件：
    - user_data.py
    - user_data_handler.py
    - user_data_processor.py
    - process_user_data.py
    - handle_user_data.py
    - user_data_utils.py
    - user_data_v2.py
    - user_data_backup.py
AI：我猜你要改的是 user_data.py（第一个）
AI：已修改完成！
你：不对，我要改的是第 7 个...
```

**问题**：
- AI 找了半天，找出一堆名字相似的
- AI 不知道该用哪个，闭着眼选第一个
- 改得乱七八糟
- **浪费 token、浪费时间、浪费精力返工**

#### 准确但依赖人的做法

```
你：帮我改 /Users/me/projects/app/src/services/user_data_processor.py
AI：好的，已找到并修改
```

准确了，但**太依赖人**——每次都要记住完整路径。

#### 更好的做法：唯一编码

```
你：帮我改 FN-007
AI：好的，FN-007 是 user_data_processor.py，位于 src/services/。
    这是用户数据处理的核心模块。你要怎么改？
```

**就像管理 500 个员工**：
- 你不会说"帮我找那个高高的、戴眼镜的、好像姓张的"
- 你会说"帮我找工号 007"
- 唯一编码 = 工号

看这个对话：

```
你：帮我改一下那个函数
AI：你是说 calculateTotal 函数吗？
你：不是，是另一个
AI：是 processData 函数？
你：也不是...
```

浪费了 3 轮对话，还没找到。

现在看这个：

```
你：帮我改一下 FN-007
AI：好的，FN-007 是 validateUserInput 函数，位于 src/utils.py 第 45 行。你要怎么改？
```

一轮搞定。

### 唯一编码的设计原则

**原则 1：看编码就知道是什么**

```
好的编码：
  SK-01      → Skill 第 1 个
  PT-TMP-03  → Pattern 时间维度 第 3 个
  TD-15      → Tech Decision 第 15 个

不好的编码：
  A001       → 这是啥？
  item_1     → 什么 item？
  data       → 太模糊
```

**原则 2：编码要连续，不能跳**

```
好：SK-01, SK-02, SK-03, SK-04
坏：SK-01, SK-02, SK-05, SK-08  （03/04/06/07 去哪了？）
```

**原则 3：一旦分配，永不改变**

```
SK-01 永远是 data-collector
即使以后重构了，SK-01 还是指它
如果删除了，编号空出来，不要复用
```

### 实战练习 2：给项目文件编码

**任务**：你有一个内容创作项目，给所有重要文件编码。

**编码表**：

```yaml
# 技能编码 (SK-xx)
SK-01: 数据采集
SK-02: 数据验证
SK-03: 可视化
SK-04: 报告生成

# 模式编码 (PT-xxx-xx)
PT-VAR-01: 标题长度与播放量关系
PT-VAR-02: 视频时长最佳区间
PT-TMP-01: 最佳发布时间
PT-TMP-02: 周期性规律

# 文档编码 (TD-xx)
TD-01: 项目启动决策
TD-02: 技术栈选型
TD-03: 数据库设计
```

**使用编码后的对话**：

```
你：PT-TMP-01 的数据有问题，置信度太高了
AI：好的，PT-TMP-01 是"最佳发布时间"模式。当前置信度是 0.92，
    但样本量只有 45 条。根据规则，样本量 < 50 时置信度不应超过 0.7。
    要我调整吗？
```

AI 立刻知道你在说什么，还能指出具体问题。

### 唯一编码的魔法：自动发现错误

这是唯一编码最强大的地方。

假设你有一个时间序列：

```
TD-01: 2026-01-01
TD-02: 2026-01-05
TD-03: 2026-01-10
TD-04: 2026-01-15
TD-05: 2350-01-20  ← 手抖打错了
TD-06: 2026-01-25
```

AI 一眼就能发现 `2350` 不对，因为：
- 前面都是 2026
- 编码是连续的
- 2350 明显异常

如果没有编码，500 条数据里找这个错误，你得看到什么时候？

---

## 第三章：对齐

### 什么是对齐？

**对齐 = 找到一个比你现在做的更好的例子，然后向它学习。**

就像学书法：
- 你写的字是 60 分
- 找到一个 80 分的字帖
- 对比差异，向字帖学习

### 对齐的核心原则

**AI 负责找例子、列差异。人负责判断、做决定。**

这一点非常重要。很多人让 AI 全自动处理，结果：
- AI 把简单的东西改复杂了
- AI 按它的"理解"改，不是你要的
- 改来改去，越改越乱

### 对齐是双向的（重要！）

很多人以为对齐就是"向更好的学习"，单向的。

**错！对齐是双向对比。**

```
你的版本（60分）  ←→  参考版本（70分）
     ↓                    ↓
  有你的优点           有它的优点
  有你的缺点           有它的缺点
```

双向对比的意思是：
- 参考版本有些地方比你好 → 你向它学
- **你的版本有些地方比参考好 → 保留你的**
- 最终结果 = 取双方精华

#### 真实案例

杨老师做开智学堂新版时：

```
规约文档（理想设计）
    ↕ 双向对比
Demo（vo.dev 生成的原型）
```

对比发现：
- 规约里有些功能设计得更完整 → Demo 要补上
- **Demo 里有些交互做得更好（规约没想到）→ 规约要更新**

**如果只是单向（让 Demo 向规约看齐），就会错过 Demo 的闪光点。**

#### 双向对比三步法

```
第一步：让 AI 列出"各自"的优缺点（不是只看一方）

第二步：你来判断：
  - 哪些是"它有我没有，我要学"
  - 哪些是"我有它没有，我要保留"
  - 哪些是"双方都有但不同，我选哪个"

第三步：两边都更新（不是只改一边）
```

### 对齐三步法

```
第一步：让 AI 找候选例子
第二步：让 AI 列出差异
第三步：你来决定改什么
```

### 实战练习 3：对齐你的项目文档

**场景**：你写了一个 README，感觉不够好，想改进。

**第一步：让 AI 找候选例子**

```
提示词：

帮我找 3 个 GitHub 上写得好的 README 案例，要求：
1. 是数据分析/可视化类项目
2. Star 数 > 1000
3. README 结构清晰、有示例代码

只需要给我项目名和链接，不要总结内容。
```

AI 返回：
```
1. streamlit/streamlit - https://github.com/streamlit/streamlit
2. plotly/dash - https://github.com/plotly/dash
3. apache/superset - https://github.com/apache/superset
```

**第二步：让 AI 列出差异**

```
提示词：

请对比我的 README（下面粘贴）和 streamlit 的 README，列出：
1. 它有但我没有的部分
2. 我有但它没有的部分
3. 都有但写法不同的部分

对于每个差异，说明哪个更好，为什么。

我的 README：
---
# YouTube 分析工具
这是一个分析 YouTube 视频的工具。

## 安装
pip install -r requirements.txt

## 使用
python main.py
---
```

AI 返回：
```
差异分析：

1. 它有但你没有：
   - 项目 Logo/Banner（更专业）
   - 功能特性列表（让用户快速了解能干什么）
   - GIF 演示（直观展示效果）
   - 贡献指南（方便社区参与）
   - License 说明

2. 你有但它没有：
   - 无

3. 都有但写法不同：
   - 安装说明：它用代码块 + 多种安装方式（pip/conda/docker）
   - 使用说明：它有完整的示例代码和输出结果
```

**第三步：你来决定改什么**

看完差异后，你决定：

```
我的决定：
✓ 加功能特性列表 - 确实需要
✓ 加示例代码和输出 - 确实需要
✗ 不加 Logo - 我这是个人项目，没必要
✗ 不加贡献指南 - 暂时不需要社区贡献
✓ 加 License - 应该有
```

然后告诉 AI：
```
按我的决定，帮我改 README：
1. 在开头加一个功能特性列表
2. 把使用说明改成有完整示例代码和输出的格式
3. 在末尾加 MIT License

不要加 Logo 和贡献指南。
```

### 为什么人必须做决定？

**理由 1：品味是主观的**

"好"的标准因人而异：
- 有人喜欢简洁，有人喜欢详细
- 有人要专业感，有人要亲和力
- 你的项目有你的定位

**理由 2：AI 会过度优化**

如果让 AI 自动改，它可能：
- 把 10 行的 README 改成 200 行
- 加一堆"最佳实践"但你用不上
- 按它训练数据里的"平均水平"改

**理由 3：上下文只有你知道**

- 这个项目是给谁用的？
- 时间紧不紧？
- 预算够不够？
- 未来要不要开源？

AI 不知道这些，只有你知道。

### 进阶技巧：从自己的尝试中找参照

前面说的是"从外部找更好的例子"。但还有一个更实用的方法：

> **对齐的"更好实例"不一定是外部找的，可以是你自己多次尝试中抽到的好版本。**

#### 为什么这样做？

大模型有**概率性**——同样的输入，可能产生不同质量的输出。

```
第一次生成：60 分
第二次生成：75 分  ← 这个好
第三次生成：50 分
```

既然会"抽到"好的和坏的，那就：
1. 多生成几个版本
2. 人来判断哪个好
3. 用好的作为参照，改进其他版本
4. 取其精华，去其糟粕

#### 为什么要"早早部署"？

```
❌ 憋到完美再部署
   → 不知道真实效果
   → 可能方向都错了
   → 浪费大量时间

✓ 早早部署
   → 马上看到真实效果
   → 马上知道哪个版本好
   → 早找到"70分版本"
   → 早开始对齐
```

**早部署 = 早拿到反馈 = 早找到参照 = 早开始进化**

#### 实战练习 3.5：多版本筛选法

**场景**：你让 AI 帮你写一个落地页文案，不确定哪种风格好。

**第一步：让 AI 生成多个版本**

```
提示词：

帮我写一个 YouTube 分析工具的落地页文案，写 3 个不同风格的版本：
- 版本 A：专业严谨风格
- 版本 B：轻松活泼风格
- 版本 C：数据驱动风格

每个版本 100 字左右。
```

**第二步：快速部署，看真实效果**

不要在本地纠结，直接部署上去，看看：
- 哪个版本你自己看着顺眼？
- 给朋友看，他们喜欢哪个？
- 如果有数据，哪个点击率高？

**第三步：用好的版本作为参照**

假设你发现版本 B 最好，但版本 A 的某个表达很精准：

```
提示词：

版本 B 整体最好，但我想把版本 A 的这句话融合进去：
"精准定位爆款规律，数据驱动创作决策"

请帮我改版本 B，融入这个表达，但保持轻松活泼的整体风格。
```

**第四步：迭代，直到满意**

```
新版本 B' 出来了
    ↓
再看看，还有什么可以改？
    ↓
版本 C 的开头不错，融合进来
    ↓
最终版本 B''
    ↓
满意了，定稿
```

#### 这个方法的本质

就像**进化论**：

| 进化论 | 多版本对齐法 |
|--------|--------------|
| 变异 | AI 生成多个版本 |
| 选择 | 人判断哪个好 |
| 遗传 | 好版本成为下一轮基础 |
| 迭代 | 重复，越来越好 |

**不是一次生成完美版本，而是通过筛选和迭代逼近完美。**

### 多层对齐：结对 + 找榜样

对齐不只是一层，可以是多层的。

#### 写作学徒的例子

```
学徒 A（60分）  ←→  学徒 B（60分）
      ↓                  ↓
   结对修改，互相学习（同级对齐）
      ↓                  ↓
     A'（70分）        B'（70分）
            ↘        ↙
              ↓    ↓
    对照 10 篇经典短篇小说（90分）
              ↓
        发现差距，学习技法（向上对齐）
              ↓
           A''（80分）
```

**两层对齐**：

| 层级 | 对齐对象 | 作用 |
|------|----------|------|
| 第一层：同级对齐 | 学徒 A ↔ 学徒 B | 取各自精华，快速提升 |
| 第二层：向上对齐 | 自己 → 经典作品 | 看到更高标准，学习榜样 |

#### 为什么多层对齐更有效？

**只做同级对齐的问题**：
- 两个 60 分互相学，最多到 70 分
- 不知道 90 分长什么样
- 容易陷入局部最优

**只做向上对齐的问题**：
- 经典作品太高，差距太大，不知道从哪学起
- 没有同级的反馈，不知道自己的优点

**两层结合**：
- 同级对齐：快速提升，发现自己的优点
- 向上对齐：看到更高标准，持续进步

#### 实战：代码开发的多层对齐

```
第一层（同级对齐）：
  - 让 AI 生成 3 个版本
  - 对比 3 个版本的各自优点
  - 融合成一个更好的版本

第二层（向上对齐）：
  - 找 GitHub 上同类项目中 Star 最高的
  - 对比自己的代码和它的代码
  - 学习它的架构、命名、设计模式
```

#### 建立你的"榜样库"

> 有一堆优秀作品作为模仿对象和学习榜样，会学习更快。

**做法**：
1. 在你的领域，收集 10 个顶级作品
2. 给每个作品编码（如 REF-01, REF-02...）
3. 每次做新东西时，先问："我的榜样库里，哪个最值得参考？"
4. 对比、学习、融合

**榜样库示例**：

```yaml
# 落地页榜样
REF-LP-01: Stripe 官网
REF-LP-02: Linear 官网
REF-LP-03: Notion 官网

# README 榜样
REF-RM-01: streamlit/streamlit
REF-RM-02: facebookresearch/llama

# 数据可视化榜样
REF-VIS-01: Our World in Data
REF-VIS-02: The Pudding
```

有了榜样库，对齐就有了明确的方向。

### 跨项目对齐：打破人的视角局限

#### 人的视角 vs AI 的视角

```
人的视角：
  "我在做项目 A，要参考项目 B？
   得先打开另一个文件夹...
   太麻烦了，算了。"

AI 的视角：
  "项目 A 在 /path/to/A，项目 B 在 /path/to/B
   都是路径而已，有什么区别？"
```

**页面是给人看的，AI 不需要"切换页面"。**

#### 跨项目对齐的威力

你可以让 AI：

```
1. 把项目 A 的好设计"搬"到项目 B
   "项目 A 的错误处理写得很好，帮我用同样的模式改项目 B"

2. 同时参考多个项目
   "对比项目 A、B、C 的数据库设计，哪个更好？"

3. 在整个电脑范围内找最佳实践
   "在我所有项目中，找出 README 写得最好的，作为参考"
```

#### 实战：跨项目找参考

```
提示词：

我有两个项目：
- 项目 A：/Users/me/projects/old-app（做了半年，比较成熟）
- 项目 B：/Users/me/projects/new-app（刚开始）

请帮我：
1. 看看项目 A 的目录结构和代码规范
2. 把好的设计模式应用到项目 B

特别关注：错误处理、日志、配置管理。
```

#### 突破"同一项目"的思维局限

```
局限的想法：
  "在这个项目里，版本 A 和版本 B 对比"

更大的视野：
  "在所有项目里，找到最好的实现，让当前项目向它学习"
```

可以对比的示例变多了，学习速度就更快了。

---

## 第四章：分组

### 什么是分组？

**分组 = 找到当前最重要的东西，优先处理它。**

不是所有事情都一样重要。分组帮你：
- 不被杂事淹没
- 确保核心功能先完成
- 减少上下文切换

### 分组的三个维度

**维度 1：优先级分组**

```
P0 阻塞级（必须立刻处理）：
   - 网站挂了
   - 数据库连不上
   - 支付功能报错

P1 高优先级（今天处理）：
   - 核心功能 bug
   - 用户反馈的严重问题

P2 中优先级（本周处理）：
   - 体验优化
   - 非核心功能 bug

P3 低优先级（有空再说）：
   - 代码重构
   - 文档补充
   - "锦上添花"的功能
```

**维度 2：时间分组**

```
数据迁移案例：

第一轮（快速验证）：
  - 目标：跑通流程
  - 允许：数据丢失、功能不全
  - 时间：1 天

第二轮（正式迁移）：
  - 目标：完整迁移
  - 冻结：24小时前的旧数据
  - 单独处理：最近的增量
  - 时间：半天
```

**维度 3：类型分组**

```
Bug 修复分组：

❌ 错误做法：
   把 10 个 bug 一次性扔给 AI

✓ 正确做法：
   1. 让 AI 分类：哪些是同一类问题？
   2. 合并同类项
   3. 一组一组处理
```

### 实战练习 4：给你的任务分组

**场景**：你接到一堆需求，不知道从哪开始。

```
需求列表：
1. 首页加载太慢
2. 用户说登录按钮颜色不好看
3. 支付失败但没有错误提示
4. 想加一个数据导出功能
5. 代码里有很多重复，想重构
6. 用户建议加深色模式
7. 有时候图表显示不出来
8. 想写个使用文档
```

**让 AI 帮你分组**：

```
提示词：

请帮我把以下需求按优先级分组（P0/P1/P2/P3），并说明理由：
（粘贴需求列表）

分组标准：
- P0：阻塞核心功能，必须立刻处理
- P1：影响用户体验，今天处理
- P2：改进项，本周处理
- P3：锦上添花，有空再说
```

AI 返回：
```
分组结果：

P0（立刻处理）：
  - #3 支付失败没有错误提示
    理由：涉及金钱，用户可能重复支付

P1（今天处理）：
  - #7 图表有时显示不出来
    理由：核心功能不稳定
  - #1 首页加载太慢
    理由：影响所有用户第一印象

P2（本周处理）：
  - #4 数据导出功能
    理由：有用但不紧急

P3（有空再说）：
  - #2 登录按钮颜色
  - #5 代码重构
  - #6 深色模式
  - #8 使用文档
```

**你来决定**：

```
同意 AI 的分组，但调整一下：
- #8 使用文档 提到 P2，因为最近用户问得多
- 其他不变
```

### 分组的黄金法则

```
1. 先分组，再干活（不要拿到任务就开始做）
2. 一次只处理一组（不要同时做 P0 和 P3）
3. P0 没清完，不碰 P1
4. 分组可以调整（新信息来了就更新）
```

---

## 第五章：完整实战案例

现在把四个概念串起来，做一个完整的项目。

### 项目背景

你要做一个"YouTube 视频分析工具"，功能：
1. 采集某个关键词的视频数据
2. 分析哪些视频表现好
3. 生成报告

### 步骤 1：定义知识单元

先想清楚，这个项目会产生哪些类型的数据？

```yaml
知识单元类型：

KU-VIDEO（视频单元）：
  - 来源：YouTube 采集
  - 字段：video_id, title, view_count, like_count, channel_name...
  - 状态：pending → validated → analyzed

KU-PATTERN（模式单元）：
  - 来源：数据分析
  - 字段：pattern_id, finding, confidence, sample_size...
  - 状态：draft → validated → published

KU-INSIGHT（洞察单元）：
  - 来源：报告生成
  - 字段：insight_id, title, recommendation...
  - 状态：draft → reviewed → final
```

### 步骤 2：设计唯一编码

```yaml
# 技能编码
SK-01: 数据采集（输入关键词，输出视频列表）
SK-02: 数据验证（检查数据完整性）
SK-03: 模式分析（找出规律）
SK-04: 报告生成（生成可读报告）

# 模式编码
PT-VAR-01: 标题长度与播放量
PT-VAR-02: 最佳视频时长
PT-TMP-01: 最佳发布时间
PT-CHA-01: 高增长频道特征

# 洞察编码
IN-01: 整体市场洞察
IN-02: 机会点洞察
IN-03: 风险点洞察
```

### 步骤 3：找参考例子做对齐

**找候选**：
```
提示词：帮我找 3 个做得好的 YouTube 分析工具/报告案例
```

**列差异**：
```
提示词：对比我的报告格式和案例 A，列出差异
```

**做决定**：
```
我的决定：
- 报告结构学案例 A（更清晰）
- 图表样式学案例 B（更好看）
- 保持我的简洁风格，不要太花哨
```

### 步骤 4：任务分组

```yaml
第一阶段（验证可行性）- 2 天：
  P0:
    - SK-01 能采集到数据
    - SK-02 数据格式正确
  允许：
    - 只采集 50 条
    - 不需要完美

第二阶段（核心功能）- 3 天：
  P1:
    - SK-03 能分析出 3 个模式
    - SK-04 能生成基础报告
  P2:
    - 报告样式优化
    - 更多模式分析

第三阶段（完善）- 持续：
  P3:
    - 自动化调度
    - 更多数据源
    - 用户界面
```

### 步骤 5：开始干活

**现在可以开始了**。每完成一个任务：

1. 检查知识单元是否符合定义
2. 编码是否正确使用
3. 遇到问题时，找更好的例子对齐
4. 时刻记住当前在哪个分组，不要跑偏

---

## 第六章：常见误区

### 误区 1："我让 AI 全自动处理"

**问题**：AI 不知道你要什么，会按它的理解乱改。

**正确**：AI 负责执行，你负责决策。

### 误区 2："编码太麻烦，不想搞"

**问题**：项目一大，你就找不到东西了，AI 也会产生幻觉。

**正确**：前期 10 分钟建立编码体系，后期节省几十小时。

### 误区 3："先做完再整理"

**问题**：做完就懒得整理了，下次还是乱。

**正确**：边做边整理，保持每个知识单元都是清晰的。

### 误区 4："什么都很重要"

**问题**：什么都重要 = 什么都不重要，最后什么都做不好。

**正确**：强制分组，P0 没做完不碰 P1。

### 误区 5："AI 说的都对"

**问题**：AI 会自信地说错话。

**正确**：AI 是助手，不是老板。它的建议你要验证。

---

## 第七章：快速检查清单

每次开始新任务前，过一遍这个清单：

```
□ 初始化（新项目必做）
  □ .gitignore 配置了吗？
  □ .claudeignore 配置了吗？
  □ CLAUDE.md 写了吗？
  □ 旧代码/大文件 已忽略？

□ 知识单元
  □ 这个任务会产生什么类型的数据？
  □ 每条数据有唯一 ID 吗？
  □ 有状态标记吗？

□ 唯一编码
  □ 相关文件/函数/模式有编码吗？
  □ 编码是连续的吗？
  □ 和 AI 对话时用编码了吗？

□ 对齐
  □ 有没有比我现在做的更好的例子？
  □ 差异列出来了吗？（双向对比：各自优缺点）
  □ 我决定了要改什么、不改什么吗？
  □ 【进阶】让 AI 生成多个版本了吗？（同级对齐）
  □ 【进阶】早部署看效果了吗？
  □ 【进阶】从好版本中提取精华了吗？
  □ 【进阶】有榜样库吗？用了哪个榜样？（向上对齐）

□ 分组
  □ 当前任务属于哪个优先级？
  □ P0 都清完了吗？
  □ 有没有在做 P3 的事而 P1 没做？
```

---

## 结语

这套方法的精髓：

> **让 AI 成为你的助手，而不是你的老板。**

- **初始化**：告诉 AI 该看什么、不该看什么，避免幻觉
- **知识单元**：让信息可追踪、可校验
- **唯一编码**：让你和 AI 说同一种语言
- **对齐**：找到更好的例子，但你来决定学什么
- **分组**：确保最重要的事情先完成

开始的时候会觉得麻烦。但一旦习惯了，你会发现：

- AI 不再产生幻觉了
- 项目再大也能保持清晰
- 效率提升 3-10 倍

**记住**：花 30 分钟做好初始化，能省下后面几十小时的混乱。

祝你实践顺利。

---

## 附录：提示词模板

### 模板 1：让 AI 找候选例子

```
帮我找 3 个 [领域] 做得好的 [东西] 案例，要求：
1. [条件1]
2. [条件2]
3. [条件3]

只给我名字和链接，不要总结内容。
```

### 模板 2：让 AI 双向对比（列出各自优缺点）

```
请对比以下两个 [东西]：
- 我的版本：[粘贴或描述]
- 参考版本：[粘贴或描述]

请从以下角度双向对比：

1. 我的版本的优点（参考版本没有的）
2. 我的版本的缺点
3. 参考版本的优点（我没有的）
4. 参考版本的缺点
5. 双方都有但实现不同的地方，各自优劣

注意：
- 这是双向对比，不是只看参考版本的优点
- 只列出差异，不要自动修改
- 我来决定学哪边的
```

### 模板 3：让 AI 帮忙分组

```
请帮我把以下 [任务/bug/需求] 按优先级分组：
[列表]

分组标准：
- P0：[你的定义]
- P1：[你的定义]
- P2：[你的定义]
- P3：[你的定义]

给出分组结果和理由。
```

### 模板 4：让 AI 按你的决定执行

```
按我的决定，帮我 [做什么]：
1. [决定1]
2. [决定2]
3. [决定3]

不要 [不要做的事]。
```

### 模板 5：多版本生成（利用概率性）

```
帮我 [做什么]，生成 3 个不同风格的版本：
- 版本 A：[风格1]
- 版本 B：[风格2]
- 版本 C：[风格3]

每个版本 [长度要求]。
```

### 模板 6：版本融合（取其精华）

```
版本 [X] 整体最好，但我想融入其他版本的一些优点：
- 从版本 [Y] 中取：[具体内容]
- 从版本 [Z] 中取：[具体内容]

请帮我改版本 [X]，融入这些内容，但保持 [整体风格要求]。
```

---

## 版本记录

| 版本 | 日期 | 变更 |
|------|------|------|
| v1.8 | 2026-02-02 | 修正表述：AI能力在迭代，人的认知决定产出差异 |
| v1.7 | 2026-02-02 | 更新"唯一编码"开头（传统做法的灾难） |
| v1.6 | 2026-02-02 | 添加"跨项目对齐"（AI视角下，不同项目可互相借鉴） |
| v1.5 | 2026-02-02 | 添加"CEO思维"（AI是实习生，老板认知决定产出） |
| v1.4 | 2026-02-02 | 添加"多层对齐"（同级对齐 + 向上对齐 + 榜样库） |
| v1.3 | 2026-02-02 | 添加"双向对比"（规约 vs Demo 各自优缺点） |
| v1.2 | 2026-02-02 | 添加"进阶技巧：多版本筛选"（利用大模型概率性，早部署早对齐） |
| v1.1 | 2026-02-02 | 添加"第零章：项目初始化"（Git/Claude忽略、CLAUDE.md） |
| v1.0 | 2026-02-02 | 初始版本：知识单元、唯一编码、对齐、分组 |
