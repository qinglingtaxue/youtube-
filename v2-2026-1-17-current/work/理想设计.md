请ultrathink，如果从一开始就知道各个板块的图表，会被“信息报告”调用，你一开始会怎么设计？是一开始就拆分成不同的模块，还
是其他方式？才能避免看不见图表，和网页卡的问题

⏺ 这是一个很好的架构反思问题。让我深入分析问题根源，然后提出理想的设计方案。

  问题根源分析

  问题1：看不见图表

  原因链：Tab 隐藏 → display: none → canvas 尺寸为 0 → Chart.js 渲染失败

  问题2：网页卡顿

  原因链：一次性加载 → 20-30 个 Chart 实例同时存在 → DOM 节点爆炸 → 内存占用高

  当前设计的核心缺陷

  当前：图表配置 + 数据 + 渲染 = 耦合在一起，一创建就渲染
  问题：无法控制"何时渲染"、"渲染几个"、"何时销毁"

  ---
  理想架构：配置驱动 + 按需渲染 + 快照缓存

  如果从一开始就知道需求，我会这样设计：

  核心思想

  ┌─────────────────────────────────────────────────────────────────┐
  │                      ChartRegistry（配置注册）                    │
  │  存储：图表ID、类型、数据源函数、配置选项、目标canvas              │
  │  关键：只是配置，不是实例！                                        │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │                      ChartManager（生命周期管理）                  │
  │  职责：按需渲染、LRU 销毁、快照缓存                                │
  │  约束：最多同时存在 N 个活跃图表实例                               │
  └─────────────────────────────────────────────────────────────────┘
                                ↓
  ┌─────────────────────────────────────────────────────────────────┐
  │                      信息报告（只用快照）                          │
  │  规则：永远使用 base64 图片，不重新渲染                            │
  │  好处：无 canvas 尺寸问题，无性能问题                              │
  └─────────────────────────────────────────────────────────────────┘

  架构代码示例

  // ========== 1. 图表注册表（纯配置，不渲染）==========
  const ChartRegistry = {
      configs: new Map(),

      register(chartId, config) {
          // config = { type, getData, options, canvasId, tabId }
          this.configs.set(chartId, {
              ...config,
              rendered: false,
              snapshotReady: false
          });
      },

      getConfig(chartId) {
          return this.configs.get(chartId);
      },

      getChartsForTab(tabId) {
          return [...this.configs.entries()]
              .filter(([_, c]) => c.tabId === tabId)
              .map(([id]) => id);
      }
  };

  // ========== 2. 图表管理器（控制生命周期）==========
  const ChartManager = {
      instances: new Map(),      // chartId → Chart 实例
      snapshots: new Map(),      // chartId → base64 图片
      renderQueue: [],           // 待渲染队列
      maxActive: 8,              // 最大同时活跃数

      // 核心：按需渲染
      async render(chartId) {
          const config = ChartRegistry.getConfig(chartId);
          if (!config) return null;

          // 检查 canvas 是否可见
          const canvas = document.getElementById(config.canvasId);
          if (!canvas || !this.isVisible(canvas)) {
              // 不可见时加入队列，等 Tab 切换时再渲染
              this.queueRender(chartId);
              return null;
          }

          // LRU 淘汰：超过最大数量时销毁最旧的
          if (this.instances.size >= this.maxActive) {
              this.destroyOldest();
          }

          // 获取数据并渲染
          const data = await config.getData();
          const chart = new Chart(canvas, {
              type: config.type,
              data: data,
              options: config.options
          });

          this.instances.set(chartId, chart);

          // 渲染后立即生成快照
          this.captureSnapshot(chartId, chart);

          return chart;
      },

      // 生成快照（用于信息报告）
      captureSnapshot(chartId, chart) {
          requestAnimationFrame(() => {
              const base64 = chart.toBase64Image('image/png', 1.0);
              this.snapshots.set(chartId, base64);
              ChartRegistry.getConfig(chartId).snapshotReady = true;
          });
      },

      // 获取快照（信息报告调用）
      getSnapshot(chartId) {
          return this.snapshots.get(chartId);
      },

      // 销毁图表（切换 Tab 时调用）
      destroy(chartId) {
          const chart = this.instances.get(chartId);
          if (chart) {
              chart.destroy();
              this.instances.delete(chartId);
          }
          // 注意：快照保留！
      },

      // 销毁某 Tab 的所有图表
      destroyTabCharts(tabId) {
          const chartIds = ChartRegistry.getChartsForTab(tabId);
          chartIds.forEach(id => this.destroy(id));
      },

      // 检查元素可见性
      isVisible(el) {
          const rect = el.getBoundingClientRect();
          return rect.width > 0 && rect.height > 0;
      },

      // LRU 销毁最旧的
      destroyOldest() {
          const oldest = this.instances.keys().next().value;
          if (oldest) this.destroy(oldest);
      }
  };

  // ========== 3. Tab 控制器（触发渲染/销毁）==========
  const TabController = {
      currentTab: null,

      switchTo(tabId) {
          // 1. 销毁旧 Tab 的图表（保留快照）
          if (this.currentTab) {
              ChartManager.destroyTabCharts(this.currentTab);
          }

          // 2. 显示新 Tab
          this.showTab(tabId);
          this.currentTab = tabId;

          // 3. 延迟渲染新 Tab 的图表
          requestAnimationFrame(() => {
              const chartIds = ChartRegistry.getChartsForTab(tabId);
              chartIds.forEach(id => ChartManager.render(id));
          });
      }
  };

  // ========== 4. 信息报告（只用快照）==========
  const InfoReport = {
      renderConclusion(chartId, containerEl) {
          const snapshot = ChartManager.getSnapshot(chartId);

          if (snapshot) {
              // 直接用 <img> 显示，无需 canvas
              const img = document.createElement('img');
              img.src = snapshot;
              img.style.width = '100%';
              containerEl.appendChild(img);
          } else {
              // 快照未就绪，显示占位
              containerEl.innerHTML = '<div class="chart-pending">图表生成中...</div>';
          }
      }
  };

  使用示例

  // 注册图表（只是配置，不渲染）
  ChartRegistry.register('durationScatter', {
      tabId: 'tab4',
      canvasId: 'durationScatterChart',
      type: 'scatter',
      getData: async () => await fetchDurationData(),
      options: { scales: { y: { type: 'logarithmic' } } }
  });

  ChartRegistry.register('countryBar', {
      tabId: 'tab1',
      canvasId: 'countryBarChart',
      type: 'bar',
      getData: async () => await fetchCountryData(),
      options: { indexAxis: 'y' }
  });

  // 切换 Tab 时自动按需渲染
  TabController.switchTo('tab1');  // 只渲染 tab1 的图表

  // 信息报告直接用快照
  InfoReport.renderConclusion('countryBar', document.getElementById('report-chart-1'));

  ---
  对比：当前设计 vs 理想设计

  | 维度     | 当前设计             | 理想设计             |
  |--------|------------------|------------------|
  | 渲染时机   | 页面加载时全部渲染        | Tab 可见时才渲染       |
  | 同时存在   | 20-30 个图表实例      | 最多 8 个（可配置）      |
  | 隐藏 Tab | 图表渲染失败（canvas=0） | 不渲染，等切换时再渲染      |
  | 信息报告   | 重新渲染/复制 canvas   | 直接用 base64 快照    |
  | 内存占用   | 高（所有图表常驻）        | 低（LRU 淘汰 + 快照轻量） |
  | 代码耦合   | 配置+渲染混在一起        | 配置、渲染、快照分离       |

  ---
  关键设计原则

  1. 配置与实例分离
    - 注册 ≠ 渲染
    - 配置随时可用，实例按需创建
  2. 快照优先于重渲染
    - 信息报告只需要"图片"，不需要交互
    - 避免在隐藏容器中渲染的所有问题
  3. 显式生命周期管理
    - 何时创建、何时销毁、何时缓存，都由 Manager 控制
    - 而不是"创建了就一直存在"
  4. LRU 约束活跃数量
    - 防止内存无限增长
    - 保证页面流畅

  ---
  迁移建议

  如果要将当前代码迁移到这个架构：

  1. 第一步：创建 ChartRegistry 和 ChartManager
  2. 第二步：将各模块的 renderPatternX() 改为先注册再渲染
  3. 第三步：修改信息报告，从 copyChartToCanvas 改为 getSnapshot
  4. 第四步：在 Tab 切换时加入 destroyTabCharts 逻辑

  这个重构可以渐进式进行，不需要一次性改完。
