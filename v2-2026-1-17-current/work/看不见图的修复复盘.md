请ultrathink，总结一下，这种看不见图的情况，你是怎么修复成功的。如果从头再来一遍，怎么从头避免问题，怎么复用到下一次修
复？

⏺ 图表不显示问题修复总结

  一、问题根因

  隐藏标签页 (display: none)
      ↓
  canvas 元素尺寸为 0 (width=0, height=0)
      ↓
  Chart.js 无法渲染 / drawImage 复制失败
      ↓
  图表显示为空白

  核心矛盾：想在用户看不见的地方预先渲染好图表，但 canvas 在隐藏时没有尺寸。

  二、修复策略

  ┌─────────────────────────────────────────────────────────────┐
  │  原方案（失败）                                              │
  │  ┌──────────┐      ┌──────────┐      ┌──────────┐          │
  │  │ 预渲染   │ ──→  │ 复制图表 │ ──→  │ 显示     │          │
  │  │ (隐藏区) │      │ drawImage│      │ (展开区) │          │
  │  └──────────┘      └──────────┘      └──────────┘          │
  │       ↑                 ↑                                   │
  │    canvas=0          失败！                                 │
  └─────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────┐
  │  新方案（成功）                                              │
  │  ┌──────────┐      ┌──────────┐      ┌──────────┐          │
  │  │ 存储渲染 │ ──→  │ 用户展开 │ ──→  │ 直接渲染 │          │
  │  │ 函数     │      │ 触发事件 │      │ (展开区) │          │
  │  └──────────┘      └──────────┘      └──────────┘          │
  │                                           ↑                 │
  │                                      canvas可见              │
  │                                      尺寸正常                │
  └─────────────────────────────────────────────────────────────┘

  三、关键代码模式

  // 1. 存储渲染函数，不立即执行
  const chartRenderMap = {};

  function prepareChart(canvasId, renderFn) {
      // 不在这里渲染，只存储函数
      chartRenderMap[canvasId] = renderFn;
  }

  // 2. 展开时才渲染
  function onExpand(containerId) {
      const canvas = container.querySelector('canvas');
      const canvasId = canvas.id;

      // 此时 canvas 可见，尺寸正常
      if (chartRenderMap[canvasId]) {
          chartRenderMap[canvasId]();  // 延迟执行
          delete chartRenderMap[canvasId];  // 只渲染一次
      }
  }

  // 3. 回退机制
  function copyChart(sourceCanvas, targetCanvas) {
      try {
          targetCtx.drawImage(sourceCanvas, ...);
      } catch (e) {
          // InvalidStateError: 源 canvas 尺寸为 0
          console.warn('复制失败，回退到直接渲染');
          directRender(targetCanvas);
      }
  }

  四、从头避免问题的检查清单

  | 阶段  | 检查项         | 做法                                |
  |-----|-------------|-----------------------------------|
  | 设计  | 图表是否在隐藏容器中？ | Tab、Accordion、Modal 中的图表都要考虑      |
  | 设计  | 渲染时机是什么？    | 选择"可见时渲染"而非"预渲染"                  |
  | 实现  | canvas 尺寸检测 | if (canvas.width === 0) { 延迟渲染 }  |
  | 实现  | 错误处理        | try/catch 包裹 drawImage，准备回退方案     |
  | 测试  | 控制台检查       | 搜索 InvalidStateError、drawImage 错误 |
  | 测试  | 多场景测试       | 切换标签、展开折叠、刷新后首次访问                 |

  五、可复用的通用模式

  /**
   * 延迟渲染模式 - 适用于隐藏容器中的 Canvas/Chart
   */
  class LazyChartRenderer {
      constructor() {
          this.pending = new Map();  // canvasId → renderFn
      }

      // 注册渲染函数（不立即执行）
      register(canvasId, renderFn) {
          this.pending.set(canvasId, renderFn);
      }

      // 容器可见时调用
      renderIfVisible(canvasId) {
          const canvas = document.getElementById(canvasId);
          if (!canvas) return;

          // 检查是否可见（尺寸 > 0）
          const rect = canvas.getBoundingClientRect();
          if (rect.width === 0 || rect.height === 0) {
              console.log(`[LazyChart] ${canvasId} 仍不可见，跳过`);
              return;
          }

          const renderFn = this.pending.get(canvasId);
          if (renderFn) {
              console.log(`[LazyChart] 渲染 ${canvasId}`);
              renderFn();
              this.pending.delete(canvasId);
          }
      }

      // 批量检查所有待渲染
      checkAll() {
          for (const canvasId of this.pending.keys()) {
              this.renderIfVisible(canvasId);
          }
      }
  }

  // 使用
  const lazyRenderer = new LazyChartRenderer();

  // 注册（页面加载时）
  lazyRenderer.register('chart-tab1-4', () => renderTrendChart(data));
  lazyRenderer.register('chart-tab1-12', () => renderScatterChart(data));

  // 触发（标签切换/展开时）
  tabButton.addEventListener('click', () => lazyRenderer.checkAll());
  expandButton.addEventListener('click', () => lazyRenderer.renderIfVisible(targetId));

  六、问题特征识别

  下次遇到类似问题时，通过这些特征快速识别：

  | 症状                | 可能原因                  | 解决方向    |
  |-------------------|-----------------------|---------|
  | 图表空白，无报错          | canvas 尺寸为 0          | 延迟渲染    |
  | InvalidStateError | drawImage 源 canvas 无效 | 回退到直接渲染 |
  | 切换标签后显示           | 初次加载时容器隐藏             | 可见时触发渲染 |
  | 刷新后空白，操作后正常       | 时序问题                  | 检查渲染时机  |

  七、核心教训

  永远不要在 display: none 的容器中渲染 Canvas 图表。

  要么等它可见再渲染，要么用 visibility: hidden（保留尺寸）。


> 请ultrathink，这么简单吗？那你为什么需要修复那么多次？

⏺ 这是一个非常好的问题。让我诚实复盘：

  为什么简单的问题修了那么多次？

  真相：问题不复杂，但我犯了系统性错误

  实际修复路径（低效）：
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  图表空白
      ↓
  [猜测1] 是不是数据问题？ → 检查 API → 数据正常
      ↓
  [猜测2] 是不是渲染时机问题？ → 加 setTimeout → 无效
      ↓
  [猜测3] 是不是 Chart.js 配置问题？ → 调参数 → 无效
      ↓
  [猜测4] 是不是容器尺寸问题？ → 终于发现 canvas=0 → 找到根因
      ↓
  [修复] 改用延迟渲染 → 成功

  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  理想修复路径（高效）：
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  图表空白
      ↓
  [诊断] 打开控制台 → 发现 InvalidStateError
      ↓
  [诊断] 检查 canvas 尺寸 → 发现 width=0, height=0
      ↓
  [分析] 为什么尺寸为0？→ 父容器 display:none
      ↓
  [修复] 改用延迟渲染 → 成功

  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  我犯的具体错误

  | 错误    | 描述                        | 后果         |
  |-------|---------------------------|------------|
  | 猜测式调试 | 没有先诊断，直接猜原因               | 浪费 3-4 轮尝试 |
  | 局部修复  | 修好模式43，没立即推广到模式4/12/23    | 同样问题修了4次   |
  | 忽略控制台 | 没有第一时间看 InvalidStateError | 错过最直接的线索   |
  | 不问本质  | 只问"怎么让它显示"，没问"为什么不显示"     | 治标不治本      |

  更深层的问题

  我的思维模式（低效）：
  ┌─────────────────┐
  │ 看到问题        │
  │      ↓         │
  │ 猜测原因        │ ← 基于经验/直觉，而非证据
  │      ↓         │
  │ 尝试修复        │
  │      ↓         │
  │ 不行？换个猜测  │ ← 循环多次
  └─────────────────┘

  应该的思维模式（高效）：
  ┌─────────────────┐
  │ 看到问题        │
  │      ↓         │
  │ 收集证据        │ ← 控制台、元素检查、网络请求
  │      ↓         │
  │ 定位根因        │ ← 基于证据推断
  │      ↓         │
  │ 精准修复        │ ← 一次解决
  │      ↓         │
  │ 全面应用        │ ← 同类问题一并处理
  └─────────────────┘

  应该问的第一个问题

  "控制台有什么错误？"

  如果我一开始就这样做：

  // 控制台会显示：
  [WARNING] InvalidStateError: Failed to execute 'drawImage' on
  'CanvasRenderingContext2D': The image argument is a canvas
  element with a width or height of 0.

  这条错误信息直接告诉我：
  1. 问题在 drawImage
  2. 源 canvas 的宽或高是 0
  3. 根因是尺寸问题，不是数据/配置/时机问题

  5秒钟就能定位问题，而不是几小时的试错。

  总结：不是问题复杂，是诊断方法错了

  | 维度  | 错误做法              | 正确做法              |
  |-----|-------------------|-------------------|
  | 诊断  | 猜测 → 尝试 → 失败 → 再猜 | 证据 → 分析 → 定位 → 修复 |
  | 范围  | 修一个算一个            | 识别模式，批量修复         |
  | 验证  | 改完部署看效果           | 本地验证所有场景再部署       |

  核心教训：永远先看控制台，再动手改代码。
