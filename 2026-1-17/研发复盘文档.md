# 目录

- [产品的定位和目标用户](#产品的定位和目标用户)
- [使用的技术栈和工具](#使用的技术栈和工具)
- [遇到的挑战和解决方案](#遇到的挑战和解决方案)
- [使用的核心提示词](#使用的核心提示词)
- [对认知敏捷法的理解和实践心得](#对认知敏捷法的理解和实践心得)
  - [初始化](#初始化)
  - [meta：任务书](#meta任务书)
  - [cog：地图](#cog地图)
  - [real：法律法规](#real法律法规)
  - [spec：行动计划](#spec行动计划)
  - [work：经验日志](#work经验日志)
  - [skill：技能库](#skill技能库)
  - [什么时候该写什么提示词？](#什么时候该写什么提示词)
  - [什么时候该更新哪些文档？](#什么时候该更新哪些文档)
- [使用的 AI 模型](#使用的-ai-模型)
- [迭代计划（选填）](#迭代计划选填)

---

# 产品的定位和目标用户

## 产品定位

**诗歌心智可视化平台**——让诗歌意象「看得见」，让创作有人陪，让每首诗都成为一件艺术品。

### 核心痛点

- **理解困难**：诗歌意象太抽象，读者难以直观理解诗人在表达什么。尤其对新手而言，"读不懂"是最大的阻碍。
- **缺乏动力**：想写诗却不知从何下手，写完后也缺乏反馈和成就感，难以保持持续创作的热情。

---

## 目标用户

### 主要用户画像

**诗歌新手**：对诗歌感兴趣，但读不太懂、也不敢写。
- 核心需求：降低理解门槛，获得创作勇气
- 产品价值：**意象分析 + 3D 可视化**让抽象意象变得「可见」，帮助用户直观理解一首诗在表达什么；**AI 诗人导师**提供入门陪伴，遇到困惑可以随时请教；**探索海滩**展示他人作品的美好，激发用户学诗的念头

**诗歌创作者**：有创作经验，但缺乏反馈和持续动力。
- 核心需求：获得创作反馈，保持创作热情
- 产品价值：**AI 诗人导师**既能答疑解惑、提供改诗建议，也能作为创作者追随的角色榜样。当你灰心或迷茫，可以从诗人的人生故事里获得启发和陪伴；**我的贝壳**收藏展示作品，写得越多、珍珠越多，激发成就感；还能把作品下载成画册，作为**礼物**送给朋友、恋人、亲人——即使不发表到诗刊，写诗也多了一层实用的意义

产品的独特价值在于：**写诗时沉浸其中，读诗时心有所动，每首诗都像贝壳里孕育的珍珠，是暗夜中的光芒，是心海里的岛屿。**

# 使用的技术栈和工具

## 技术栈

核心框架

  - Next.js：React 全栈框架，参考：https://github.com/vercel/next.js
  - React：UI 库，参考：https://github.com/facebook/react
  - TypeScript：类型安全，参考：https://github.com/microsoft/TypeScript

  UI 组件

  - Tailwind CSS：样式框架，参考：https://github.com/tailwindlabs/tailwindcss
  - Radix UI：无障碍组件库，参考：https://github.com/radix-ui/primitives
  - Lucide React：图标库，参考：https://github.com/lucide-icons/lucide
  - Framer Motion：React 动画，参考：https://github.com/framer/motion

  3D 与动画

  - Three.js：3D 引擎，参考：https://github.com/mrdoob/three.js
  - postprocessing：后期处理特效，参考：https://github.com/pmndrs/postprocessing
  - GSAP：高性能动画，参考：https://github.com/greensock/GSAP

  状态管理

  - Zustand：全局状态，参考：https://github.com/pmndrs/zustand
  - Jotai：原子化状态，参考：https://github.com/pmndrs/jotai
  - TanStack Query：服务端状态/缓存，参考：https://github.com/TanStack/query
  - TanStack Virtual：虚拟列表，参考：https://github.com/TanStack/virtual

  数据库

  - PostgreSQL：数据库，参考：https://www.postgresql.org/docs/
  - Drizzle ORM：ORM，参考：https://github.com/drizzle-team/drizzle-orm
  - @neondatabase/serverless：Neon 云数据库驱动，参考：https://github.com/neondatabase/serverless

  认证与安全

  - Better Auth：认证框架，参考：https://github.com/better-auth/better-auth
  - bcrypt：密码加密，参考：https://github.com/kelektiv/node.bcrypt.js
  - Zod：数据验证，参考：https://github.com/colinhacks/zod

  AI 服务

  - Vercel AI SDK：AI 集成框架，参考：https://github.com/vercel/ai
  - @ai-sdk/openai：OpenAI 适配器，参考：https://github.com/vercel/ai
  - @ai-sdk/anthropic：Anthropic 适配器，参考：https://github.com/vercel/ai
  - 支持 5 个 AI 提供商：MiniMax、智谱、OpenAI、Anthropic、DeepSeek

  桌面应用

  - Electron：桌面框架，参考：https://github.com/electron/electron
  - electron-builder：打包工具，参考：https://github.com/electron-userland/electron-builder

  测试工具

  - Vitest：单元测试，参考：https://github.com/vitest-dev/vitest
  - Playwright：E2E 测试，参考：https://github.com/microsoft/playwright
  - Testing Library：组件测试，参考：https://github.com/testing-library/react-testing-library

  开发工具

  - Bun：运行时/包管理，参考：https://github.com/oven-sh/bun
  - ESLint：代码检查，参考：https://github.com/eslint/eslint
  - drizzle-kit：数据库迁移，参考：https://github.com/drizzle-team/drizzle-kit-mirror
  - tsx：TypeScript 执行器，参考：https://github.com/privatenumber/tsx

# 遇到的挑战和解决方案

开发过程中，我的想法经历了好几次推倒重来。最初我想模仿飞书做一个 3D 画板，后来想做成类似知乎的社区，再后来我把社区砍掉了，只专注一件事：**让用户在创作时感受到心流，保持充足的内驱力。**这个过程让我意识到，功能不需要多，只要能让用户沉浸其中、爱上创作，就够了。

最终，我把产品精简为四个核心部分：

- **笔记**是创作的载体。用户在上面写诗、保存，想写多少写多少。

- **AI 诗人**扮演两个角色。一个是**答疑**：创作时遇到困惑，直接和它聊。另一个是**角色榜样**：当你灰心或迷茫，可以从它的人生故事里获得启发和陪伴。

- **我的贝壳**用来收藏和展示作品。我设计了两种视图：一种是**左边诗歌、右边 3D 宇宙图**，寓意每首诗都像贝壳里诞生的珍珠；另一种是**纯 3D 宇宙图**，寓意每首诗都是你心智宇宙在某个时空呈现的世界。写得越多，珍珠越多，留下的时空世界也越多。用户可以把视图保存下来，下载成画册；像是把那个时空凝固成一件艺术品，自己珍藏或分享给朋友。

   **意义生发**：原本抓耳挠腮不知道写什么的情境，变成了「我要创作什么礼物」。这一刻，产品从理性的工具软件变成感性的「礼物生成器」。写好的诗如果不发表，可以送朋友、送恋人、送亲人。即使不发表到诗刊、不成为一流诗人，写诗也多了一层实用的用途。

- 每首诗写完后，还可以生成**意象分析**，看看诗中的意象会**激活大脑的哪些区域**，并据此生成专属的**3D 宇宙图**。发布时可以选择仅自己看，也可以公开。公开的诗会出现在**「探索海滩」**，让其他人也能看到。

  **意义生发**：这个功能帮助那些没那么敏感、想象力没那么丰富的新手诗人，能够直观理解一首诗可能在写什么。当有人在**探索海滩**感受到诗歌的美好，说不定也会被激发出想学诗的念头。

  后记：

  没上课之前，我已经用 Claude 设计过一个模仿飞书的产品了。当时我侧重于画板功能：用户可以把左侧的组件拖拽到右侧的画板中，形成 3D 动态图。右侧还有解析诗歌的功能。退出 3D 画板后，系统会自动保存。从预览页面，用户可以看到画板最后一次保存的状态。

  当时我设计的构思是：左侧展示人在情境中感受到什么，中间展示人形成了怎样的知觉符号，右侧展示知觉符号如何转化成语言符号。

  当时我设计这个画板的初心是：帮助别人也能轻松画出 3D 动态图。因为总会被人问到怎么能画出可视化的图。所以我想了很久，那就设计一些可复用的组件，来帮助别人画出他们想画的图。但我又不满足于像飞书一样的纯粹图形，于是设计了更具象化的 3D 动态图。

  学了课程之后，我对这个产品进行了三个方向的迭代。

  **方向一：这个产品是为什么样的人设计的？**
  一开始我没什么思路。后来我想到了之前跟朋友的聊天，她跟我讲了很多她的焦虑。所以，新产品的思考方向变成：如何设计，才能帮助到像她一样的新手诗人。

  **方向二：怎么让用户成为故事的主角？**
  我思考了很久，才想到：如果写诗本身就是在创作一件艺术品呢？这不就是一种意义吗？于是，又延伸出了不同视图的设计。

  **方向三：产品的整体意象是什么？**
  产品的整体故事我构思了好多版本，最后想到可以用"每个诗人都像维纳斯"的隐喻。但因为原图太原生态了，怕引起别人的不适，就改成贝壳和珍珠的隐喻。


# 使用的核心提示词

我让 Claude 帮我从聊天记录中总结出高频使用的提示词，大致有这几类：

| 模式 | 子模式 | 示例说法 |
|------|--------|----------|
| **一、问题复盘** | 1.1 复盘总结 | "遇到什么问题，解决什么问题，是意料之外还是可避免，需优化哪些文档" |
| | 1.2 给足上下文 | "结合 [文件A] 和 [文件B]，思考是否要优化 [目标]" |
| **二、深度分析** | 2.1 ultrathink | "请 ultrathink，分析/提炼 [目标] 中的 [内容]" |
| **三、对比优化** | 3.1 对比检查 | "对比 [来源A] 和 [来源B]，找出差异或遗漏" |
| **四、路径定位** | 4.1 URL + 问题 | "[URL] [问题描述]" |
| | 4.2 本地路径 + 操作 | "[路径] [操作]，并同步更新到 [平台]" |
| | 4.3 截图 + 问题 | "[发送截图] [问题/操作]" |
| **五、检查原因** | 5.1 现象 + 检查 | "[现象描述]，你检查一下是什么原因" |
| | 5.2 检查 + 目标 | "检查 [目标]，看看 [验证内容]" |
| **六、方案选择** | 6.1 阅读 + 对比 | "阅读 [文件]，思考 [方案A] 还是 [方案B]？" |
| | 6.2 征求建议 | "[决策问题]，你的建议呢？" |
| **七、知识沉淀** | 7.1 同步更新 | "请将 [变更] 同步更新到 [文档]" |
| | 7.2 总结为技能书 | "将经验总结为技能书，支持下次复用" |
| | 7.3 注册软连接 | "将 [技能] 通过软连接注册到 .claude 目录" |

# 对认知敏捷法的理解和实践心得

想让大模型干好活，得先让它知道自己要在一个什么样的世界里干活。那这是一个什么世界呢？这是一个由人类投射到电脑里的数字世界，由项目、文件、代码构成。在这个世界中，本地电脑的环境配置和存放的文件，就是大模型开启新游戏时的初始装备。当人类想要指挥大模型干活的时候，其实是把自己的认知工程化，让自己的某一个数字分身进入这个数字世界升级打怪。**meta、cog、real、spec 这四层文档就是这个工程化的脚手架。**

## 初始化

数字分身进入数字世界后，需要先知道自己生活在一个什么样的环境。所以开发的第一步是**初始化**：生成一份 CLAUDE.md，为数字分身搭建起它即将生活的世界；同时把 skill 注册为软链接，让数字分身拥有可调用的技能库。就像玩游戏的时候，一开始就会让你选择需要的设备和技能。把项目推送到 GitHub 或 CNB 上建立版本基线，就是给这个世界留下初始快照。后续的每一次更新都可以被跟踪到，如果对新版本不满意，就可以退回之前的状态。

## meta：任务书

**meta 是任务书**，由人类手动填写，告诉数字分身这个项目是什么、做什么、给谁用。

## cog：地图

**cog 根据 meta 生成，是数字世界的地图**，让数字分身知道这里有什么。

cog 文档厘清这个系统里存在哪些实体、哪些属性、哪些关系，为后续数字分身理解系统中实体的演化做准备，也为它理解如何设计数据模型做好铺垫。

cog 只定义锚点：**每个实体的唯一编码和分类方式**。什么是 id？id 是实体在数字世界存在过的证明。什么是分类？分类是实体的形态之一，在人类的日常生活中已经约定俗成了，比如使用产品的人，人们基本上会把他们分成游客、用户、管理员等。这些要由人类明确分类，不能让数字分身自己推断。

通过明确定义唯一编码和分类方式，就把握住了数据模型的锚点。

## real：法律法规

**real 根据 meta 生成，是数字世界的法律法规**，让数字分身知道什么不能做。

real 文档不是列出所有规则，而是专门列出数字分身不容易想到的约束。数字分身已经知道"代码要能运行"这些显而易见的事情，但它不知道"来访者信息必须加密""支付数据不能存储在本地"这些来自现实世界的硬约束。这就给数字分身界定了一个操作边界，告诉它这个数字世界和它训练时见过的世界有哪些不同，哪些事情在这里是禁忌。

## spec：行动计划

文档从 meta 到 cog、real、再到 spec 是逐层递进的，是**内隐知识逐步变清晰的过程**。spec 是根据任务书、地图和法律法规生成的行动计划，它把 cog 里的实体和 real 里的约束结合起来，转化成可执行的规约。

spec 目录按角色分成不同层次：pm 目录放产品经理视角的文档，dev 目录放开发者视角的文档。

生成顺序有严格依赖：**先根据 cog 和 real 生成 pr.spec**（定义用户能做什么），**再根据 pr 生成 userstory.spec**（定义用户会经历什么），**最后根据前面所有文档生成 sys.spec**（定义系统怎么实现）。

数字分身读完这些文档，就知道要造一个什么样的产品、用户会怎么用它、代码应该怎么写。

下面的例子来自我项目里的 spec 文档，是让 Claude 根据 meta 生成的。

### pr.spec：用户能做什么

比如这个诗歌创作平台的 pr.spec 里写的作品集管理可供性：

> **行动启用**: 查看和管理个人所有作品
> - **感知**: "我的作品集"导航链接，作品卡片网格/列表
> - **人类**: 点击进入 /my-poems 页面，查看所有作品（公开+私密）
> - **AI**: GET /api/poems?userId={id}，返回当前用户所有作品
> - **反馈**: 作品列表显示，支持编辑/删除/切换可见性

这段描述把一个功能拆成了四个维度：

用户看到什么（导航链接、作品卡片）；
人怎么操作（点击进入页面）；
AI 怎么操作（GET 接口）；
操作完会看到什么反馈（列表显示出来了）。

在这里，AI 和人一样，都是这个系统的用户，只是交互方式不同：人点按钮，AI 调接口。数字分身读完这份规约，调用 dev-coding 技能，就会像前端工程师一样设计：导航栏要加"我的作品集"链接，页面要渲染作品卡片；像后端工程师一样设计：要提供 GET /api/poems?userId={id} 接口，返回的数据要能支持编辑、删除、切换可见性。

### userstory.spec：用户会经历什么

userstory.spec 使用两个核心框架来描述用户故事：

**框架一：MAS（感知-行动-反馈）**

MAS 描述用户和系统之间的交互循环：

- **感知（Perception）**：用户能看到什么？比如"显著的创作按钮"、"光标闪烁的输入框"、"右上角已保存提示"
- **行动（Action）**：用户会做什么？比如"点击创作按钮"、"输入诗歌内容"、"点击保存"
- **反馈（Feedback）**：系统怎么响应？比如"打开编辑器"、"自动保存草稿"、"跳转到详情页"

一个完整的 MAS 序列例子：
> 1. 进入创作：用户点击创作按钮进入诗歌编辑器（感知：显著的"创作"按钮）
> 2. 文本输入：用户在编辑器中输入诗歌内容（感知：光标闪烁的输入框）
> 3. 自动保存：系统自动保存草稿防止丢失（感知：右上角"已保存"提示）
> 4. AI 解析：诗歌完成后系统自动触发五象解析（感知：解析进度条）
> 5. 3D 生成：系统基于解析结果生成可视化场景（感知：3D 场景渲染动画）

**框架二：三个最小故事（Light, Dark, Grey）**

每个用户故事都按情感体验分成三种类型：

**Light Story（从差到好）**：用户获得正向体验的故事
> - 例子：MS-L-01 创建第一首诗歌
> - 起始状态：创作者有灵感但没有工具，无法将心智表征可视化
> - 转折点：系统提供了直观的编辑器和自动保存机制
> - 终点状态：用户成功创作并保存了第一首诗歌
> - 情感体验：从"担心创作丢失"→"安心创作"→"成就感"

**Dark Story（从好到差再恢复）**：用户遇到问题但被系统帮助恢复的故事
> - 例子：MS-D-01 处理诗歌保存失败
> - 起始状态：用户正在顺利创作诗歌
> - 转折点：网络中断或服务器错误导致保存失败
> - 终点状态：系统提示错误原因，提供重试和本地保存选项，用户恢复创作
> - 情感体验：从"顺利创作"→"焦虑受阻"→"安心恢复"

**Grey Story（循环养成习惯）**：用户逐渐形成使用习惯的故事
> - 例子：MS-G-01 日常创作自动保存
> - 循环模式：用户每次创作时，系统每 30 秒或每 200 字符自动保存
> - 优化点：从需要手动保存到完全自动化，减少认知负担
> - 习惯养成：从"不放心，频繁手动保存"→"信任系统"→"专注创作"
> - 情感体验：从"费力"→"轻松"→"自动化"

MVP 阶段的黄金比例是：**70% Light + 20% Dark + 10% Grey**。Light 故事为主展示核心价值，Dark 故事处理异常情况建立信任，Grey 故事培养使用习惯。

**验收标准格式：假设-当-那么**

每个故事都有具体的验收标准，用"假设-当-那么"格式描述：

> 假设：用户已登录并进入创作页面；当：用户点击"创作"按钮；那么：系统打开诗歌编辑器，光标自动聚焦到输入框。

这种格式，数字分身可以直接翻译成测试代码。

### sys.spec：系统怎么实现

sys.spec 里会写技术细节：保存诗歌要调用哪个接口、数据库里诗歌表有哪些字段、3D 渲染用什么引擎。数字分身照着这个就能生成后端代码、数据库迁移脚本和渲染模块。

**数据模型就是在 sys.spec 里完成的。cog 只画骨架（锚点），sys.spec 往骨架上填血肉。**

比如 cog 里写了：
> - 用户有唯一编码（UUID）、分类方式（游客、注册用户、管理员）；
> - 诗歌有唯一编码（UUID）、分类方式（公开、私密）；
> - 用户和诗歌是一对多关系。

这些是人类模糊的自然语言，只抓住了"谁是谁"和"怎么分类"，还没说具体有什么属性。

sys.spec 在锚点基础上，把人类模糊的自然语言翻译成机器能执行的精确技术语言，并根据实际需求补充必要的字段：

用户表 users：
> - id（uuid 类型，主键），对应 cog 里的"唯一编码 UUID"；
> - role（enum 类型，值为 guest/user/admin），对应 cog 里的"分类方式"；
> - email（text 类型，唯一），如果用户需要用邮箱登录，sys.spec 就会补充这个字段；

诗歌表 poems：
> - id（uuid 类型，主键），对应 cog 里的"唯一编码"；
> - visibility（enum 类型，值为 private/public），对应 cog 里的"分类方式"；
> - authorId（uuid 类型，外键关联 users.id），对应 cog 里的"一对多关系"，外键就是指向另一个实体的标记，每首诗通过 authorId 指回它的作者；
> - content（text 类型），如果诗歌需要保存正文内容，sys.spec 就会补充这个字段。

**锚点确保了核心概念不走样，其他字段由数字分身根据实际需求推导。**有了实体、关系，基础的数字世界就搭建起来了；有了实体的属性、状态、关键行动等设定，世界可能发生的变化也孕育而生。

更重要的是，**spec 不只是给人读的文档，它本身就是自动化执行的依据**。

## work：经验日志

**work 是数字分身在这个世界里积累的经验日志。**每次重要的技术决策、遇到的问题和解决方案都记录在这里。这样每次更新文档的时候可以同步更新到 CNB 或 GitHub 上，下一次对话时数字分身可以从这个文件恢复上下文，理解为什么现在是这样，避免推翻之前的决定或重蹈覆辙。

## skill：技能库

在把阳老师给的模板用于自己开发产品的过程中，我需要调整给数字分身看的参考资料，以及生成自己想实现某种特定功能的 skill 文档，并将 skill 注册为软链接。这些参考资料就像已经写好的实战帖，方便数字分身根据需要灵活查阅。**软链接的作用是让这些技能可以跨项目共享，同时保持单一数据源。**我需要做的是识别出哪些技能是通用的可以直接用，哪些需要基于自己的业务场景定制新的 skill。

不同的技能就像数字分身的不同工具箱。比如 **dev-coding 是施工工具箱**，里面装着写代码需要的各种工具，数字分身拿着它就能把设计图变成真正能跑的房子；**dev-quality-assurance 是验收工具箱**，里面装着各种检测仪器，数字分身拿着它就能检查房子盖得对不对、结不结实。

## 什么时候该写什么提示词？

理解了前面说的框架逻辑之后，每一个步骤该写什么提示词就变得清晰多了。因为每一步提示词，都是在帮助数字分身完成框架里的某一个环节。

**认识世界**

一开始初始化项目的时候，数字分身刚来到一个全新的数字世界，它什么都不知道，所以需要从零开始生成 CLAUDE.md。了解好环境后，再把 .42plugin/42edu/ 下的技能注册为软链接，让数字分身知道自己有哪些技能可以调用。

**理解任务**

人类在 .42cog/meta/meta.md 中定义这个产品要解决什么问题，告诉数字分身这个项目是什么、做什么、给谁用。填完之后，让数字分身参考 .42cog/meta/meta.md 生成 cog 和 real，这样它就了解了这个数字地图和法律法规。

**制定计划**

这个阶段要按顺序生成三份 spec，每一份都依赖前一份的产出：

第一步，生成 pr.spec，让数字分身参考：
- .42cog/cog/cog.md（知道有哪些实体和关系）
- .42cog/real/real.md（知道什么不能做）

第二步，生成 userstory.spec，让数字分身参考：
- .42cog/cog/cog.md
- .42cog/real/real.md
- spec/pm/pr.spec.md（知道用户能做什么，才能写用户会经历什么）

第三步，生成 sys.spec，让数字分身参考：
- .42cog/cog/cog.md
- .42cog/real/real.md
- spec/pm/pr.spec.md
- spec/pm/userstory.spec.md（知道用户会经历什么，才能设计系统怎么实现）

**动手干活**

搭建数据库的时候，让数字分身调用 dev-database-design 技能，参考：
- .42cog/meta/meta.md（知道产品是什么，才能确定数据库整体结构）
- .42cog/real/real.md（知道什么不能做，避免设计违规的存储方式）
- .42cog/cog/cog.md（知道有哪些实体和关系，才能设计对应的表）
- spec/pm/pr.spec.md（知道用户能做什么，才能设计需要存储哪些数据）
- spec/pm/userstory.spec.md（知道用户会经历什么，才能设计数据的状态变化）
- spec/dev/sys.spec.md（知道系统怎么实现，才能确定字段类型和约束）
- https://neon.com/guides/neon-auth-nextjs（neon 官方文档）

生成 src/lib/db/schema.ts 后，跑 drizzle-kit push 把表结构推送到 neon 数据库。

生成 UI 的时候，让数字分身调用 design-ui-design 技能，参考：
- .42cog/meta/meta.md（知道产品是什么、给谁用，才能确定整体风格）
- .42cog/real/real.md（知道什么不能做，避免设计违规的交互）
- .42cog/cog/cog.md（知道有哪些实体，才能设计对应的页面）
- spec/pm/pr.spec.md（知道用户能做什么，才能设计对应的按钮和入口）
- spec/pm/userstory.spec.md（知道用户会经历什么，才能设计完整的交互流程）
- spec/dev/sys.spec.md（知道系统怎么实现，才能设计和后端对接的界面）

写 CRUD 代码的时候，让数字分身调用 dev-coding 技能，参考的资料和生成 UI 一样。这个技能负责实际的代码实现，比如生成增删改查的接口、写前后端对接的代码、创建 seed 脚本灌测试数据。

跑测试的时候，让数字分身调用 dev-quality-assurance 技能，主要参考 spec/pm/userstory.spec.md，因为测试用例就是从用户故事里来的。这个技能负责自动化测试，API 层用 bun 直接调用接口测试，UI 层配置 Playwright 做端到端测试。

加认证的时候，让数字分身调用 dev-coding 技能，除了前面那些资料，还要参考 src/lib/db/schema.ts，因为认证需要和数据库里的用户表对接。

部署上线的时候，让数字分身调用 dev-vercel-deployment 技能，代码推送到 GitHub 就自动部署到 vercel 了。

**每一步提示词都在告诉数字分身：现在你该做什么了，需要看哪些资料。**理解了框架，就知道为什么要按这个顺序来；理解了顺序，就知道每一步提示词在干什么、该参考什么。两者是相互印证的。

参考资料的层层递进也有规律：一开始什么都没有，人类先手动填写 meta；有了 meta 才能生成 cog 和 real；有了 cog 和 real 才能生成 spec；有了 spec 才能开始写代码。**每一步都依赖前一步的产出，像搭积木一样，底层不稳，上层就搭不起来。**

## 什么时候该更新哪些文档？

理解了这个依赖关系，也就知道当有变更的时候，需要更新哪些文档：

- **产品定位变了**。比如我一开始想模仿飞书做一个 3D 画板，后来改成做诗歌创作平台，再后来把社区功能砍掉，只专注"让用户在创作时感受到心流"。每次大改方向，都要从 .42cog/meta/meta.md 开始重写，然后重新生成 cog、real、所有的 spec。相当于整个项目推倒重来。

- **增加了新功能模块**。比如我后来加了"意象-脑区映射"功能（MS-L-02a），需要展示诗歌意象激活大脑的哪些区域。这时候要更新 .42cog/cog/cog.md 加入新实体，然后更新 pr.spec、userstory.spec、sys.spec，还要在 schema.ts 里加 imageryAnalysis 表，跑 drizzle-kit push 推送到数据库。UI 和代码也要跟着改。

- **修改了某个交互细节**。比如我把作品可见性的默认值从"公开"改成"私密"，让用户可以先只给自己看，想好了再公开。这时候只需要更新 spec/pm/userstory.spec.md（加上可见性切换场景）和 spec/dev/sys.spec.md（加上 visibility 字段默认值），然后改对应的代码就行。

- **数据库表结构变了**。比如后来要区分管理员和普通用户，就要在 sys.spec 里加 role 字段定义，然后在 schema.ts 的用户表加 role 字段，跑 drizzle-kit push 推送到数据库。

- **发现某个 skill 不够用**。比如 3D 渲染相关的问题反复出现（后处理 threshold 过高导致画面全黑、React 严格模式导致 canvas 重复渲染），我就把这些问题和解决方案整理成了专门的 dev-3d-visualization 技能书，下次遇到类似问题数字分身就能直接参考。

- **技术栈变了、架构设计原则变了、或者踩了新的坑总结出新的经验**。比如我在开发过程中遇到过：.gitignore 写成 chat/，结果把 src/app/api/mentors/chat/ 也忽略了，导致 405 错误。这些坑都要记录到 CLAUDE.md 里，这样数字分身下次对话时能读到，避免再踩同样的坑。

**变更越底层，影响范围越大；变更越上层，影响范围越小。**这也是为什么一开始要把 meta、cog、real 想清楚——因为它们是地基，地基一动，上面全得跟着动。

但这个没办法避免。一开始的想法总是模糊的，只能是多跟 AI 沟通想法，让想法变得更清晰一些，再执行。或者在实践过程中把旧版本的 meta、cog、real 更新到最符合实际的版本，作为下一个版本的模板，然后再让 AI 生成新的代码。

# 使用的 AI 模型

一开始用了 MiniMax API Plan，后来用 Claude 的会员套餐。

# 迭代计划（选填）

没想好，感觉后面要迭代起来，会很复杂。

---

ref：
- spec/pm/pr.spec.md
- spec/pm/userstory.spec.md
- spec/pm/userstory/CS-01-poetry-creation.md
- spec/dev/sys.spec.md
- notes/20251206-1.md
- chat/2025-12-23/更新 meta、cog、skill.md
- chat/2025-12-25/06-更新用户需求和用户故事.md
- chat/2025-12-26/技能更新、优化聊天记录.md
- chat/2025-12-26/重构 3d 画板实际效果优化.md
- chat/2025-12-28/用户故事更新.md
