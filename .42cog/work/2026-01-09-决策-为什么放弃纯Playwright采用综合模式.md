# 复盘：为什么放弃纯 Playwright，采用综合模式

> 日期：2026-01-09
> 基于对话记录：2026-01-07 (3个会话) + 2026-01-08 (2个会话)

---

## 一、纯 Playwright 的实际问题（具体例子）

### 1. 使用额度限制中断

**文件**: `2026-01-07-cd413044.md`
**时间**: 14:28:09

```
Limit reached resets 5pm (Asia/Shanghai) · /upgrade to Max 20x or turn on /extra-usage
```

**影响**：视频上传任务被迫中断，需要等到下午 5 点重置后才能继续。

---

### 2. API 费用上限中断

**文件**: `2026-01-07-d1d7024f.md`
**时间**: 17:51:22

```json
{
  "error": {
    "code": "DAILY_COST_LIMIT",
    "message": "每日费用已达到 $40 的限制"
  },
  "details": {
    "currentCost": 40.095058,
    "costLimit": 40,
    "resetAt": "2026-01-08T00:00:00.000Z"
  }
}
```

**影响**：当日无法继续，必须等到次日 0 点重置。

---

### 3. 请求超时与连续 API 错误

**文件**: `2026-01-07-d44bf32b.md`

| 时间 | 错误 |
|------|------|
| 16:06:44 | `Request timed out` |
| 16:23:12 | `Cannot read properties of undefined (reading 'map')` |
| 16:35:32 | `SERVICE_REQUEST_INVALID` |
| 16:37:06 | `SERVICE_REQUEST_INVALID` |
| 16:37:32 | `SERVICE_REQUEST_INVALID` |
| 17:05:18 | `SERVICE_REQUEST_INVALID` |

**影响**：用户多次说"继续"都无法恢复，封面上传功能完全失效。

---

### 4. 中断后的恢复成本

**文件**: `2026-01-07-d44bf32b.md` (15:18:03)

> **会话中断时**：浏览器页面关闭
> **新会话恢复时**：需要重新打开浏览器
> **这是不可避免的**，因为：
> 1. Claude Code 每个会话是独立的
> 2. Playwright MCP 的浏览器实例是会话级别的
> 3. 会话结束后浏览器进程会关闭

每次中断后恢复需要：
1. 开启新会话
2. 重新打开浏览器
3. 重新导航到 YouTube Studio
4. 检查哪些视频已上传/是草稿
5. 重新计算发布时间

---

## 二、为什么纯 Playwright 消耗高

**文件**: `2026-01-08-7226a606.md`

### Token 消耗公式

```
Token消耗 = AI交互次数 × 每次交互的平均tokens

纯Playwright: 10视频 × 4交互 × 5000tokens = 200,000 tokens
综合方法:     1次理解 × 1000tokens = 1,000 tokens
```

### 核心差异

| 模式 | AI 的位置 | Token 消耗 |
|------|----------|-----------|
| 纯 Playwright | AI 在**执行循环中**，每一步都消耗 | 极高 |
| 综合模式 | AI 只在**入口处**，解析意图后退出 | 极低 |

---

## 三、综合模式的核心思想

**来源**: `2026-01-08-7226a606.md` (12:34:41)

> 其实，就是把复杂系统分割成**不变的程序**和**变动的参数**。固定的执行动作保留，变动的参数由 Claude 理解。

### 架构图

```
┌─────────────────────────────────────────────────────────┐
│  AI（大脑）        程序（手脚）       文件（记忆）         │
│  ───────────       ─────────         ─────────          │
│  • 理解意图         • 执行操作        • 保存状态          │
│  • 生成参数         • 处理错误        • 记录进度          │
│  • 回答问题         • 断点恢复        • 存储日志          │
│                                                         │
│  (一次性消耗)       (持续运行)        (持久化)           │
└─────────────────────────────────────────────────────────┘
```

---

## 四、RPA 的问题与 Playwright 的补救价值

### RPA 脚本的盲区

**文件**: `2026-01-08-7226a606.md` (14:23:56 ~ 14:27:28)

RPA 报告"10/10 成功"，但用户指出：

> 今天是 8 号，但下载成功的记录还停留在 6 号

**问题**：RPA 是"盲人"——只会按坐标点击，不知道点到了什么。

```
RPA 视角：点击了 → 报告成功 ✓
实际情况：点击了空白处 → 下载失败 ✗
```

### Playwright 探索发现的正确流程

**原认知**（RPA 脚本的错误假设）：
```python
# 选项按钮一直可见，直接点击
pyautogui.click(x=选项按钮位置)
```

**正确流程**（Playwright 发现）：
```
hover视频行 → 选项按钮出现 → 点击选项 → 菜单弹出 → 点击下载
```

| 步骤 | 原认知 | 正确认知 |
|------|--------|----------|
| 1 | 选项按钮始终可见 | **选项按钮是隐藏的** |
| 2 | 直接点击选项 | **需要先 hover 到视频行** |
| 3 | - | hover 后才显示选项按钮 |
| 4 | 点击下载 | 点击选项 → 弹出菜单 → 点击下载 |

---

## 五、综合模式 B+C

**文件**: `2026-01-08-7226a606.md` (14:53:12)

### 模式 B：Playwright 制定标准 → RPA 执行

```
[探索阶段] Playwright + AI → 发现正确流程 → 写入 RPA 脚本
[执行阶段] RPA 按脚本执行 → 验收 → 报告结果
```

### 模式 C：验收失败时触发重新探索

```
RPA 执行 → 验收失败 → 触发 Playwright 重新探索 → 更新脚本 → 重试
```

### 验收机制的实现

**验收标准已写入 RPA 脚本**：`youtube-uploader/youtube-tool.py`

| 行号 | 函数 | 说明 |
|------|------|------|
| 1252-1269 | `verify_download()` | GUI 模式验收 |
| 2204-2223 | `verify_download_cli()` | CLI 模式验收 |

```python
# youtube-tool.py 中的验收逻辑

def verify_download(self, keyword, before_files, timeout=30):
    """验收标准：检查是否有包含关键词的新文件出现"""
    for _ in range(timeout):
        time.sleep(1)
        after_files = self.get_download_files()
        new_files = after_files - before_files
        for f in new_files:
            if keyword.lower() in os.path.basename(f).lower():
                self.update_download_step(f"✓ 验收通过: {os.path.basename(f)}")
                return True
    self.update_download_step(f"✗ 验收失败: 未找到 {keyword} 的下载文件")
    return False
```

**关键点**：
- 验收机制**不需要 Playwright**，只需要检测文件系统（`~/Downloads/*.mp4`）
- 验收逻辑**已内置在 RPA 脚本中**，每次下载自动执行验收
- 验收失败时报告具体哪个关键词失败，便于定位问题

---

## 六、策略蒸馏

**文件**: `2026-01-08-7226a606.md` (14:54:34)

> Agent 探索 → 提取知识 → 固化到脚本 → 脚本自主执行

这是一种**策略蒸馏**：
- Agent（Claude）通过试错学到正确流程
- 把学到的知识"写死"到 RPA 脚本
- 未来执行时**不再需要 Agent**

### Agent 的真正价值

不是每次都当 Agent 执行，而是：
1. **一次探索** → 多次复用
2. **遇到变化** → 重新探索
3. **知识沉淀** → 变成代码

---

## 七、Token 消耗对比总结

| 方案 | 描述 | Token 消耗 |
|------|------|-----------|
| **方案一** | AI → 参数 → RPA 执行（成功） | ~1,000 |
| **方案二** | 纯 Playwright MCP | ~150,000-200,000 |
| **方案三** | RPA 失败 + Playwright 补救 | ~160,000-210,000（探索成本） |
| **综合模式** | Playwright 探索一次 + RPA 执行 N 次 | ~15,000 一次性 + 后续 0 |

---

## 八、结论

### 放弃纯 Playwright 的原因

1. **频繁中断**：使用额度限制、费用上限、请求超时
2. **恢复成本高**：每次重启需要重新打开浏览器、导航、检查进度
3. **Token 消耗极高**：每个操作步骤都消耗 token

### 综合模式的价值

1. **关注点分离**：不变的执行动作 → 程序；变动的参数 → AI 理解
2. **一次探索多次复用**：Playwright 发现正确流程，RPA 按标准执行
3. **验收机制**：文件检测即可，不需要 Playwright
4. **成本可控**：探索是一次性成本，执行 0 token

### 最终架构

```
用户意图（自然语言）
       ↓
   AI 理解需求（消耗少量 token）
       ↓
   生成结构化参数
       ↓
   RPA 执行（不消耗 token）
       ↓
   验收检测（文件系统）
       ↓
   失败？→ Playwright 重新探索 → 更新 RPA 脚本
```
